package wrap

const (
	wrapperTemplate = `// Code generated by gofr.dev/cli/gofr. DO NOT EDIT.
package {{ .Package }}

import (
	"context"
	"fmt"
	"reflect"
	"time"

	"gofr.dev/pkg/gofr"
	"gofr.dev/pkg/gofr/container"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

type {{ .Service }}ServerWithGofr interface {
{{- range .Methods }}
	{{- if not .Streaming }}
	{{ .Name }}(*gofr.Context) (any, error)
	{{- end }}
{{- end }}
}

type {{ .Service }}ServerWrapper struct {
	{{ .Service }}Server
	Container *container.Container
	server    {{ .Service }}ServerWithGofr
}

{{- range .Methods }}
{{- if not .Streaming }}
func (h *{{ $.Service }}ServerWrapper) {{ .Name }}(ctx context.Context, req *{{ .Request }}) (*{{ .Response }}, error) {
	gctx := h.GetGofrContext(ctx, &{{ .Request }}Wrapper{ctx: ctx, {{ .Request }}: req})

	start := time.Now()
	res, err := h.server.{{ .Name }}(gctx)
	if err != nil {
		return nil, err
	}

	duration := time.Since(start)
	gctx.Metrics().RecordHistogram(ctx, "app_gRPC-Server_stats", 
									float64(duration.Milliseconds())+float64(duration.Nanoseconds()%1e6)/1e6, 
									"gRPC_Service", "{{ $.Service }}", "method", "{{ .Name }}")

	resp, ok := res.(*{{ .Response }})
	if !ok {
		return nil, status.Errorf(codes.Unknown, "unexpected response type %T", res)
	}

	return resp, nil
}
{{- end }}

{{- end }}

func (h *{{ .Service }}ServerWrapper) mustEmbedUnimplemented{{ .Service }}Server() {}

func Register{{ .Service }}ServerWithGofr(app *gofr.App, srv {{ .Service }}ServerWithGofr) {
	var s grpc.ServiceRegistrar = app

	wrapper := &{{ .Service }}ServerWrapper{server: srv}

	gRPCBuckets := []float64{0.005, 0.01, .05, .075, .1, .125, .15, .2, .3, .5, .75, 1, 2, 3, 4, 5, 7.5, 10}
	app.Metrics().NewHistogram("app_gRPC-Server_stats", "Response time of gRPC server in milliseconds.", gRPCBuckets...)

	Register{{ .Service }}Server(s, wrapper)
}

func (h *{{ .Service }}ServerWrapper) GetGofrContext(ctx context.Context, req gofr.Request) *gofr.Context {
	return &gofr.Context{
		Context:   ctx,
		Container: h.Container,
		Request:   req,
	}
}

{{- range $request := .Requests }}
type {{ $request }}Wrapper struct {
	ctx context.Context
	*{{ $request }}
}

func (h *{{ $request }}Wrapper) Context() context.Context {
	return h.ctx
}

func (h *{{ $request }}Wrapper) Param(s string) string {
	return ""
}

func (h *{{ $request }}Wrapper) PathParam(s string) string {
	return ""
}

func (h *{{ $request }}Wrapper) Bind(p interface{}) error {
	ptr := reflect.ValueOf(p)
	if ptr.Kind() != reflect.Ptr {
		return fmt.Errorf("expected a pointer, got %T", p)
	}

	hValue := reflect.ValueOf(h.{{ $request }}).Elem()
	ptrValue := ptr.Elem()

	// Ensure we can set exported fields (skip unexported fields)
	for i := 0; i < hValue.NumField(); i++ {
		field := hValue.Type().Field(i)
		// Skip the fields we don't want to copy (state, sizeCache, unknownFields)
		if field.Name == "state" || field.Name == "sizeCache" || field.Name == "unknownFields" {
			continue
		}

		if field.IsExported() {
			ptrValue.Field(i).Set(hValue.Field(i))
		}
	}

	return nil
}

func (h *{{ $request }}Wrapper) HostName() string {
	return ""
}

func (h *{{ $request }}Wrapper) Params(s string) []string {
	return nil
}

{{- end }}
`

	serverTemplate = `package {{ .Package }}

import "gofr.dev/pkg/gofr"

// Register the gRPC service in your app using the following code in your main.go:
//
// {{ .Package }}.Register{{ $.Service }}ServerWithGofr(app, &{{ .Package }}.{{ $.Service }}GoFrServer{})
//
// {{ $.Service }}GoFrServer defines the gRPC server implementation.
// Customize the struct with required dependencies and fields as needed.

type {{ $.Service }}GoFrServer struct {
}

{{- range .Methods }}
func (s *{{ $.Service }}GoFrServer) {{ .Name }}(ctx *gofr.Context) (any, error) {
// Uncomment and use the following code if you need to bind the request payload
// request := {{ .Request }}{}
// err := ctx.Bind(&request)
// if err != nil {
//     return nil, err
// }

return &{{ .Response }}{}, nil
}
{{- end }}
`
	clientTemplate = `// Code generated by gofr.dev/cli/gofr. DO NOT EDIT.
package {{ .Package }}

import (
	"io"
	"fmt"
	"encoding/json"
	"time"

	"gofr.dev/pkg/gofr"
	"gofr.dev/pkg/gofr/metrics"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/metadata"
)

const (
	statusCodeWidth  = 3
	responseTimeWidth = 11
)

type RPCLog struct {
	ID           string ` + "`json:\"id\"`\n" +
		`StartTime    string ` + "`json:\"startTime\"`\n" +
		`ResponseTime int64  ` + "`json:\"responseTime\"`\n" +
		`Method       string ` + "`json:\"method\"`\n" +
		`StatusCode   int32  ` + "`json:\"statusCode\"`\n" +
		`}

type {{ .Service }}GoFrClient interface {
{{- range .Methods }}
	{{ .Name }}(*gofr.Context, *{{ .Request }}) (*{{ .Response }}, error)
{{- end }}
}

type {{ .Service }}ClientWrapper struct {
	client    {{ .Service }}Client
	{{ .Service }}GoFrClient
}

func createGRPCConn(host string) (*grpc.ClientConn, error) {
	conn, err := grpc.Dial(host, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		return nil, err
	}
	return conn, nil
}

func New{{ .Service }}GoFrClient(host string, metrics metrics.Manager) (*{{ .Service }}ClientWrapper, error) {
	conn, err := createGRPCConn(host)
	if err != nil {
		return &{{ .Service }}ClientWrapper{client: nil}, err
	}
	
	gRPCBuckets := []float64{0.005, 0.01, .05, .075, .1, .125, .15, .2, .3, .5, .75, 1, 2, 3, 4, 5, 7.5, 10}
	metrics.NewHistogram("app_gRPC-Client_stats", "Response time of gRPC client in milliseconds.", gRPCBuckets...)

	res := New{{ .Service }}Client(conn)
	return &{{ .Service }}ClientWrapper{
		client: res,
	}, nil
}

{{- range .Methods }}
func (h *{{ $.Service }}ClientWrapper) {{ .Name }}(ctx *gofr.Context, req *{{ .Request }}) (*{{ .Response }}, error) {
	span := ctx.Trace("gRPC-srv-call: {{ .Name }}")
	defer span.End()

	traceID := span.SpanContext().TraceID().String()
	spanID := span.SpanContext().SpanID().String()
	md := metadata.Pairs("x-gofr-traceid", traceID, "x-gofr-spanid", spanID)

	ctx.Context = metadata.NewOutgoingContext(ctx.Context, md)

	var header metadata.MD
	
	transactionStartTime := time.Now()

	res, err := h.client.{{ .Name }}(ctx.Context, req, grpc.Header(&header))
	if err != nil {
		return nil, err
	}

	duration := time.Since(transactionStartTime)

	ctx.Metrics().RecordHistogram(ctx, "app_gRPC-Client_stats", 
									float64(duration.Milliseconds())+float64(duration.Nanoseconds()%1e6)/1e6, 
									"gRPC_Service", "{{ $.Service }}", 
									"method", "{{ .Name }}")

	log := &RPCLog{}

	if values, ok := header["log"]; ok && len(values) > 0 {
		errUnmarshal := json.Unmarshal([]byte(values[0]), log)
		if errUnmarshal != nil {
			return nil, fmt.Errorf("error while unmarshaling: %v", errUnmarshal)
		}
	}

	ctx.Logger.Info(log)

	return res, err
}

func (l RPCLog) PrettyPrint(writer io.Writer) {
	fmt.Fprintf(writer, "\u001B[38;5;8m%s \u001B[38;5;%dm%-*d"+
		"\u001B[0m %*d\u001B[38;5;8mÂµs\u001B[0m %s\n",
		l.ID, colorForGRPCCode(l.StatusCode),
		statusCodeWidth, l.StatusCode,
		responseTimeWidth, l.ResponseTime,
		l.Method)
}

func colorForGRPCCode(s int32) int {
	const (
		blue = 34
		red  = 202
	)

	if s == 0 {
		return blue
	}

	return red
}

{{- end }}
`
)
